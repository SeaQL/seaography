//! SeaORM Entity. Generated by sea-orm-codegen 0.9.1



use sea_orm :: entity :: prelude :: * ;

# [derive (Copy , Clone , Default , Debug , DeriveEntity)] pub struct Entity ;

impl EntityName for Entity { fn table_name (& self) -> & str { "tracks" } }

# [derive (Clone , Debug , PartialEq , DeriveModel , DeriveActiveModel)] pub struct Model { pub track_id : i32 , pub name : String , pub album_id : Option < i32 > , pub media_type_id : i32 , pub genre_id : Option < i32 > , pub composer : Option < String > , pub milliseconds : i32 , pub bytes : Option < i32 > , pub unit_price : f64 , }

# [derive (Copy , Clone , Debug , EnumIter , DeriveColumn)] pub enum Column { # [sea_orm (column_name = "TrackId")] TrackId , # [sea_orm (column_name = "Name")] Name , # [sea_orm (column_name = "AlbumId")] AlbumId , # [sea_orm (column_name = "MediaTypeId")] MediaTypeId , # [sea_orm (column_name = "GenreId")] GenreId , # [sea_orm (column_name = "Composer")] Composer , # [sea_orm (column_name = "Milliseconds")] Milliseconds , # [sea_orm (column_name = "Bytes")] Bytes , # [sea_orm (column_name = "UnitPrice")] UnitPrice , }

# [derive (Copy , Clone , Debug , EnumIter , DerivePrimaryKey)] pub enum PrimaryKey { TrackId , }

impl PrimaryKeyTrait for PrimaryKey { type ValueType = i32 ; fn auto_increment () -> bool { true } }

# [derive (Copy , Clone , Debug , EnumIter)] pub enum Relation { MediaTypes , Genres , Albums , InvoiceItems , PlaylistTrack , }

impl ColumnTrait for Column { type EntityName = Entity ; fn def (& self) -> ColumnDef { match self { Self :: TrackId => ColumnType :: Integer . def () , Self :: Name => ColumnType :: String (None) . def () , Self :: AlbumId => ColumnType :: Integer . def () . null () , Self :: MediaTypeId => ColumnType :: Integer . def () , Self :: GenreId => ColumnType :: Integer . def () . null () , Self :: Composer => ColumnType :: String (None) . def () . null () , Self :: Milliseconds => ColumnType :: Integer . def () , Self :: Bytes => ColumnType :: Integer . def () . null () , Self :: UnitPrice => ColumnType :: Double . def () , } } }

impl RelationTrait for Relation { fn def (& self) -> RelationDef { match self { Self :: MediaTypes => Entity :: belongs_to (super :: media_types :: Entity) . from (Column :: MediaTypeId) . to (super :: media_types :: Column :: MediaTypeId) . into () , Self :: Genres => Entity :: belongs_to (super :: genres :: Entity) . from (Column :: GenreId) . to (super :: genres :: Column :: GenreId) . into () , Self :: Albums => Entity :: belongs_to (super :: albums :: Entity) . from (Column :: AlbumId) . to (super :: albums :: Column :: AlbumId) . into () , Self :: InvoiceItems => Entity :: has_many (super :: invoice_items :: Entity) . into () , Self :: PlaylistTrack => Entity :: has_many (super :: playlist_track :: Entity) . into () , } } }

impl Related < super :: media_types :: Entity > for Entity { fn to () -> RelationDef { Relation :: MediaTypes . def () } }

impl Related < super :: genres :: Entity > for Entity { fn to () -> RelationDef { Relation :: Genres . def () } }

impl Related < super :: albums :: Entity > for Entity { fn to () -> RelationDef { Relation :: Albums . def () } }

impl Related < super :: invoice_items :: Entity > for Entity { fn to () -> RelationDef { Relation :: InvoiceItems . def () } }

impl Related < super :: playlist_track :: Entity > for Entity { fn to () -> RelationDef { Relation :: PlaylistTrack . def () } }

impl ActiveModelBehavior for ActiveModel { }