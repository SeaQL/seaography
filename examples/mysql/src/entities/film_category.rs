# ! [doc = " SeaORM Entity. Generated by sea-orm-codegen 0.9.1"] use sea_orm :: entity :: prelude :: * ; # [derive (Copy , Clone , Default , Debug , DeriveEntity)] pub struct Entity ; impl EntityName for Entity { fn table_name (& self) -> & str { "film_category" } } # [derive (Clone , Debug , PartialEq , DeriveModel , DeriveActiveModel , async_graphql :: SimpleObject , seaography_derive :: Filter)] # [sea_orm (table_name = "film_category")] # [graphql (complex)] # [graphql (name = "FilmCategory")] pub struct Model { pub film_id : u16 , pub category_id : u8 , pub last_update : DateTimeUtc , } # [derive (Copy , Clone , Debug , EnumIter , DeriveColumn)] pub enum Column { FilmId , CategoryId , LastUpdate , } # [derive (Copy , Clone , Debug , EnumIter , DerivePrimaryKey)] pub enum PrimaryKey { FilmId , CategoryId , } impl PrimaryKeyTrait for PrimaryKey { type ValueType = (u16 , u8) ; fn auto_increment () -> bool { false } } # [derive (Copy , Clone , Debug , EnumIter)] pub enum Relation { Category , Film , } impl ColumnTrait for Column { type EntityName = Entity ; fn def (& self) -> ColumnDef { match self { Self :: FilmId => ColumnType :: SmallUnsigned . def () , Self :: CategoryId => ColumnType :: TinyUnsigned . def () , Self :: LastUpdate => ColumnType :: Timestamp . def () , } } } # [seaography_derive :: relation] impl RelationTrait for Relation { fn def (& self) -> RelationDef { match self { Self :: Category => Entity :: belongs_to (super :: category :: Entity) . from (Column :: CategoryId) . to (super :: category :: Column :: CategoryId) . into () , Self :: Film => Entity :: belongs_to (super :: film :: Entity) . from (Column :: FilmId) . to (super :: film :: Column :: FilmId) . into () , } } } impl Related < super :: category :: Entity > for Entity { fn to () -> RelationDef { Relation :: Category . def () } } impl Related < super :: film :: Entity > for Entity { fn to () -> RelationDef { Relation :: Film . def () } } impl ActiveModelBehavior for ActiveModel { }